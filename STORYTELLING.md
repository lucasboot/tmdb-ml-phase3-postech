# üìñ Storytelling do Projeto - TMDB Horror Movies Predictor

## üéØ Contexto e Motiva√ß√£o

### O Problema
Como prever a popularidade e o sucesso de filmes de terror antes do lan√ßamento? Produtores, distribuidores e plataformas de streaming precisam tomar decis√µes baseadas em dados para:
- Definir or√ßamento de marketing
- Escolher a melhor data de lan√ßamento
- Identificar filmes sub ou super-avaliados
- Entender padr√µes de sucesso no g√™nero horror

### A Solu√ß√£o
Sistema automatizado que coleta dados de filmes de terror do TMDB, treina modelos de Machine Learning e gera predi√ß√µes e insights em tempo real atrav√©s de um dashboard web interativo.

---

## üèóÔ∏è Arquitetura do Sistema

### Vis√£o Geral dos Componentes

```mermaid
graph TB
    subgraph "Camada de Apresenta√ß√£o"
        A[Dashboard Web<br/>Flask + Jinja2 + Chart.js]
    end
    
    subgraph "Camada de API"
        B[Flask REST API<br/>endpoints /api/*]
    end
    
    subgraph "Camada de Processamento Ass√≠ncrono"
        C[Celery Worker<br/>executa tasks]
        D[Celery Beat<br/>scheduler]
    end
    
    subgraph "Camada de Dados"
        E[(MySQL Database<br/>8 tabelas)]
        F[(Redis<br/>broker + backend)]
    end
    
    subgraph "Servi√ßos Externos"
        G[TMDB API<br/>fonte de dados]
    end
    
    subgraph "Camada de ML"
        H[Pipeline ML<br/>scikit-learn]
    end
    
    A -->|polling 30s| B
    B -->|query SQL| E
    D -->|agenda tasks| F
    F -->|distribui tasks| C
    C -->|coleta dados| G
    C -->|persiste dados| E
    C -->|treina modelos| H
    H -->|salva predi√ß√µes| E
    
    style A fill:#4CAF50
    style B fill:#2196F3
    style C fill:#FF9800
    style D fill:#FF9800
    style E fill:#9C27B0
    style F fill:#F44336
    style G fill:#00BCD4
    style H fill:#FFC107
```

---

## üîÑ Fluxo de Dados Completo

### 1. Coleta de Dados (Data Ingestion)

```mermaid
sequenceDiagram
    participant Beat as Celery Beat
    participant Redis
    participant Worker as Celery Worker
    participant TMDB as TMDB API
    participant DB as MySQL
    
    Note over Beat: A cada 5 minutos
    Beat->>Redis: agenda task_update_movies
    Redis->>Worker: envia task
    
    loop Para cada ano 2010-atual
        Worker->>TMDB: GET /discover/movie?year=X&genre=27
        TMDB-->>Worker: 20 p√°ginas de filmes
        
        loop Para cada filme
            Worker->>DB: INSERT/UPDATE em movies
            Worker->>DB: INSERT em movie_snapshots
        end
    end
    
    Worker-->>Redis: task conclu√≠da ‚úì
    Note over DB: ~5.000 filmes de terror<br/>armazenados
```

**Detalhes da Coleta:**
- **Frequ√™ncia:** A cada 5 minutos
- **Per√≠odo:** 2010 at√© ano atual
- **Filtro:** Horror (Genre ID 27) + m√≠nimo 50 votos
- **Volume:** ~20 p√°ginas por ano = ~5.000 filmes
- **Estrat√©gia:** Upsert (atualiza existentes, insere novos)

---

### 2. Treinamento dos Modelos ML

```mermaid
sequenceDiagram
    participant Beat as Celery Beat
    participant Redis
    participant Worker as Celery Worker
    participant DB as MySQL
    participant ML as Pipeline ML
    
    Note over Beat: A cada 1 hora
    Beat->>Redis: agenda task_train
    Redis->>Worker: envia task
    
    Worker->>DB: SELECT filmes de terror
    DB-->>Worker: ~5.000 registros
    
    Worker->>ML: extract_horror_features()
    ML-->>Worker: 14 features por filme
    
    par Treinamento Paralelo
        Worker->>ML: train_horror_regression()
        ML->>ML: RandomForestRegressor<br/>100 √°rvores, depth=10
        ML->>DB: salva feature_importance<br/>em horror_regression
        ML->>DB: salva predi√ß√µes<br/>em horror_regression_predictions
        
        Worker->>ML: train_horror_classification()
        ML->>ML: RandomForestClassifier<br/>alta/baixa avalia√ß√£o
        ML->>DB: salva confusion_matrix<br/>roc_curve em horror_classification
        
        Worker->>ML: train_horror_clustering()
        ML->>ML: KMeans + PCA<br/>4 clusters
        ML->>DB: salva clusters<br/>em horror_clustering
        ML->>DB: salva perfis<br/>em horror_cluster_profiles
    end
    
    Worker-->>Redis: task conclu√≠da ‚úì
    Note over DB: Modelos atualizados<br/>prontos para consulta
```

**Detalhes do Treinamento:**
- **Frequ√™ncia:** A cada 1 hora
- **Algoritmos:** Random Forest (Regress√£o + Classifica√ß√£o) + K-Means
- **Features:** 14 vari√°veis (runtime, vote_count, release_month, genres, etc.)
- **M√©tricas:** MAE, R¬≤, Accuracy, AUC, Confusion Matrix

---

### 3. Visualiza√ß√£o no Dashboard

```mermaid
sequenceDiagram
    participant Browser as Browser
    participant Flask as Flask Server
    participant API as API Routes
    participant DB as MySQL
    
    Browser->>Flask: GET /
    Flask-->>Browser: index.html + main.js
    
    Note over Browser: Polling a cada 30s
    
    loop Atualiza√ß√£o Autom√°tica
        Browser->>API: GET /api/horror/regression/features
        API->>DB: query horror_regression
        DB-->>API: top 10 features + m√©tricas
        API-->>Browser: JSON response
        
        Browser->>API: GET /api/horror/regression/predictions
        API->>DB: query horror_regression_predictions + movies
        DB-->>API: predi√ß√µes com t√≠tulos
        API-->>Browser: JSON response
        
        Browser->>API: GET /api/horror/classification
        API->>DB: query horror_classification
        DB-->>API: confusion matrix + ROC
        API-->>Browser: JSON response
        
        Browser->>API: GET /api/horror/clustering/pca
        API->>DB: query horror_clustering + movies
        DB-->>API: clusters com coordenadas PCA
        API-->>Browser: JSON response
        
        Browser->>API: GET /api/horror/clustering/profiles
        API->>DB: query horror_cluster_profiles
        DB-->>API: perfis m√©dios dos clusters
        API-->>Browser: JSON response
        
        Browser->>Browser: Chart.js renderiza 6 gr√°ficos
    end
```

**Gr√°ficos do Dashboard:**
1. **Feature Importance** - Barras horizontais (top 10 features)
2. **Real vs Predicted** - Scatter plot (popularidade)
3. **Confusion Matrix** - Barras (TN, FP, FN, TP)
4. **ROC Curve** - Linha (TPR vs FPR)
5. **Cluster Analysis** - Scatter colorido (PCA 2D)
6. **Cluster Profiles** - Barras agrupadas (m√©dias)

---

## üõ†Ô∏è Jornada do Desenvolvimento

### Fase 1: Infraestrutura Base
```mermaid
graph LR
    A[Docker Compose] --> B[Container MySQL]
    A --> C[Container Redis]
    A --> D[Container Init-DB]
    D --> E[Cria√ß√£o de Tabelas]
    E --> F[Infraestrutura Pronta]
    
    style F fill:#4CAF50
```

**Decis√µes T√©cnicas:**
- Docker Compose para orquestra√ß√£o
- MySQL para dados relacionais (suporta JOIN complexos)
- Redis como broker do Celery (r√°pido, em mem√≥ria)
- Init-DB como servi√ßo separado (idempot√™ncia)

---

### Fase 2: Aplica√ß√£o Flask
```mermaid
graph LR
    A[Factory Pattern] --> B[create_app]
    B --> C[Blueprints API]
    B --> D[Blueprints Dashboard]
    B --> E[SQLAlchemy ORM]
    B --> F[Templates Jinja2]
    
    style B fill:#2196F3
```

**Decis√µes T√©cnicas:**
- Application Factory para flexibilidade
- Blueprints para modulariza√ß√£o
- SQLAlchemy ORM para abstra√ß√£o do banco
- Gunicorn com threads para concorr√™ncia

---

### Fase 3: Sistema de Tarefas Ass√≠ncronas
```mermaid
graph TB
    A[Celery App] --> B[Tasks]
    A --> C[Beat Schedule]
    
    B --> D[task_update_movies<br/>coleta incremental]
    B --> E[task_train<br/>treina modelos]
    
    C --> F[Cron: 5min]
    C --> G[Cron: 60min]
    
    F -.-> D
    G -.-> E
    
    style A fill:#FF9800
```

**Decis√µes T√©cnicas:**
- Celery para processamento ass√≠ncrono
- Celery Beat para agendamento (sem cron externo)
- Tasks idempotentes (podem ser executadas m√∫ltiplas vezes)
- Context do Flask dentro das tasks (acesso ao DB)

---

### Fase 4: Integra√ß√£o com TMDB
```mermaid
graph LR
    A[tmdb.py] --> B[tmdb_get]
    B --> C[Autentica√ß√£o API Key/Bearer]
    B --> D[Rate Limiting<br/>sleep 0.3s]
    B --> E[Error Handling]
    
    A --> F[collect_movies_by_year_range]
    F --> G[Loop anos 2010-atual]
    G --> H[20 p√°ginas por ano]
    H --> I[Filtro: Horror + min_votes]
    
    style A fill:#00BCD4
```

**Decis√µes T√©cnicas:**
- Suporte duplo: API Key v3 e Bearer Token v4
- Sleep entre requests (rate limiting preventivo)
- Coleta por ano (melhor controle de pagina√ß√£o)
- Filtro de votos m√≠nimos (qualidade dos dados)

---

### Fase 5: Pipeline de Machine Learning
```mermaid
graph TB
    A[get_horror_movies] --> B[Filtra Horror<br/>do campo genres]
    B --> C[extract_horror_features<br/>14 features]
    
    C --> D[Regress√£o]
    C --> E[Classifica√ß√£o]
    C --> F[Clustering]
    
    D --> G[RandomForest<br/>100 trees]
    G --> H[MAE + R¬≤]
    H --> I[Salva em<br/>horror_regression]
    
    E --> J[RandomForest<br/>threshold=median]
    J --> K[Confusion Matrix<br/>ROC + AUC]
    K --> L[Salva em<br/>horror_classification]
    
    F --> M[KMeans<br/>4 clusters]
    M --> N[PCA 2D]
    N --> O[Salva em<br/>horror_clustering]
    
    style C fill:#FFC107
    style D fill:#FFC107
    style E fill:#FFC107
    style F fill:#FFC107
```

**Decis√µes T√©cnicas:**
- Random Forest (robusto, interpret√°vel)
- StandardScaler para normaliza√ß√£o
- Train/Test Split 75/25
- PCA para visualiza√ß√£o 2D
- Features espec√≠ficas para horror (is_october, genre_thriller)

---

### Fase 6: Frontend Interativo
```mermaid
graph LR
    A[main.js] --> B[fetchData]
    B --> C[5 endpoints API]
    
    B --> D[Chart.js]
    D --> E[6 gr√°ficos interativos]
    
    A --> F[setInterval 30s]
    F --> B
    
    E --> G[Atualiza√ß√£o autom√°tica]
    
    style D fill:#4CAF50
```

**Decis√µes T√©cnicas:**
- Chart.js para visualiza√ß√µes (leve, responsivo)
- Polling a cada 30s (dados quase em tempo real)
- Vanilla JS (sem framework pesado)
- Cores sem√¢nticas (verde=sucesso, vermelho=erro)

---

## üìä Modelo de Dados

### Schema Relacional

```mermaid
erDiagram
    movies ||--o{ movie_snapshots : "tem"
    movies ||--o{ model_predictions : "tem"
    movies ||--o{ horror_regression_predictions : "tem"
    movies ||--o{ horror_clustering : "tem"
    
    movies {
        bigint tmdb_id PK
        string imdb_id
        string title
        text overview
        date release_date
        float popularity
        int vote_count
        float vote_average
        int runtime
        text genres
        datetime updated_at
    }
    
    movie_snapshots {
        bigint id PK
        bigint tmdb_id FK
        datetime snapshot_ts
        float popularity
        int vote_count
        float vote_average
    }
    
    horror_regression {
        bigint id PK
        datetime analysis_ts
        string feature_name
        float feature_importance
        float mae
        float r2_score
    }
    
    horror_regression_predictions {
        bigint id PK
        datetime analysis_ts
        bigint tmdb_id FK
        float actual_popularity
        float predicted_popularity
    }
    
    horror_classification {
        bigint id PK
        datetime analysis_ts
        text confusion_matrix
        text roc_curve
        float auc_score
        float accuracy
    }
    
    horror_clustering {
        bigint id PK
        datetime analysis_ts
        bigint tmdb_id FK
        int cluster_id
        float pca_x
        float pca_y
    }
    
    horror_cluster_profiles {
        bigint id PK
        datetime analysis_ts
        int cluster_id
        float avg_popularity
        float avg_vote_average
        int movie_count
    }
```

**Estrat√©gia de Timestamps:**
- `analysis_ts`: Agrupa resultados de uma mesma execu√ß√£o de treinamento
- `snapshot_ts`: Permite an√°lise temporal das m√©tricas
- `updated_at`: Rastreia √∫ltima atualiza√ß√£o dos filmes

---

## üîÑ Ciclo de Vida Completo

```mermaid
graph TB
    Start([docker compose up]) --> Init[Init-DB<br/>cria tabelas]
    Init --> Services[Web + Worker + Beat<br/>iniciam]
    
    Services --> Beat1[Beat agenda<br/>task_update_movies]
    Beat1 --> Collect[Worker coleta<br/>filmes do TMDB]
    Collect --> Store[Salva em<br/>movies + snapshots]
    
    Services --> Beat2[Beat agenda<br/>task_train]
    Beat2 --> Load[Worker carrega<br/>filmes de terror]
    Load --> Extract[Extrai 14<br/>features]
    Extract --> Train[Treina 3<br/>modelos]
    Train --> Save[Salva resultados<br/>em 5 tabelas]
    
    Services --> Web[Flask serve<br/>dashboard]
    Web --> Browser[Browser carrega<br/>index.html]
    Browser --> Poll[Polling 30s<br/>chama 5 APIs]
    Poll --> Render[Chart.js renderiza<br/>6 gr√°ficos]
    
    Render -.30s.-> Poll
    Store -.5min.-> Beat1
    Save -.60min.-> Beat2
    
    style Start fill:#4CAF50
    style Render fill:#4CAF50
```

---

## üéØ Casos de Uso Pr√°ticos

### 1. Produtor de Filmes
**Pergunta:** "Quando lan√ßar meu filme de terror?"

**Resposta do Sistema:**
```
Feature Importance:
1. is_october: 0.35 ‚Üí Filmes em outubro t√™m 35% mais impacto
2. vote_count: 0.22 ‚Üí Boca-a-boca √© crucial
3. genre_thriller: 0.18 ‚Üí Misturar com thriller ajuda

Recomenda√ß√£o: Lan√ßar em outubro, investir em marketing
para gerar votos iniciais, adicionar elementos de thriller.
```

---

### 2. Distribuidor
**Pergunta:** "Quais filmes est√£o sub-avaliados?"

**Resposta do Sistema:**
```
Regression Predictions (Top 5 sub-avaliados):
1. "The Witch" ‚Üí Previsto: 85 | Real: 45 (+89%)
2. "It Follows" ‚Üí Previsto: 78 | Real: 42 (+86%)
3. "Hereditary" ‚Üí Previsto: 92 | Real: 53 (+74%)

Interpreta√ß√£o: Filmes com qualidade acima da popularidade atual.
Oportunidade para compra de direitos de distribui√ß√£o.
```

---

### 3. Plataforma de Streaming
**Pergunta:** "Quais filmes recomendar juntos?"

**Resposta do Sistema:**
```
Cluster Analysis:
- Cluster 0: Terror psicol√≥gico (avg_runtime: 105min, alta avalia√ß√£o)
- Cluster 1: Slasher cl√°ssico (avg_runtime: 90min, alta popularidade)
- Cluster 2: Terror sobrenatural (mix de caracter√≠sticas)
- Cluster 3: Terror indie (baixo or√ßamento, nicho)

Recomenda√ß√£o: Agrupar cat√°logo por cluster para melhor UX.
```

---

### 4. Analista de Mercado
**Pergunta:** "O modelo est√° acertando as previs√µes?"

**Resposta do Sistema:**
```
Regression Metrics:
- MAE: 12.5 ‚Üí Erro m√©dio de 12.5 pontos de popularidade
- R¬≤: 0.78 ‚Üí Modelo explica 78% da vari√¢ncia

Classification Metrics:
- Accuracy: 0.85 ‚Üí 85% de acerto alta/baixa avalia√ß√£o
- AUC: 0.91 ‚Üí Excelente capacidade discriminativa

Interpreta√ß√£o: Modelo confi√°vel, mas pode melhorar com mais features.
```

---

## üöÄ Evolu√ß√£o Futura

### Roadmap T√©cnico

```mermaid
timeline
    title Evolu√ß√£o do Sistema
    
    Fase 1 (Atual) : Coleta automatizada
                   : 3 modelos ML
                   : Dashboard b√°sico
    
    Fase 2 (Pr√≥xima) : Deep Learning (LSTM para s√©ries temporais)
                      : Features de NLP (an√°lise de overview)
                      : API p√∫blica com autentica√ß√£o
    
    Fase 3 (Futuro) : An√°lise de sentiment (reviews)
                    : Predi√ß√£o de bilheteria
                    : Integra√ß√£o com outras fontes de dados
    
    Fase 4 (Vis√£o) : Sistema de recomenda√ß√£o personalizado
                   : An√°lise de trailers (computer vision)
                   : Predi√ß√£o de sucesso em streaming
```

### Melhorias Planejadas

**1. Features Avan√ßadas:**
- An√°lise de sentimento do overview (NLP)
- Extra√ß√£o de keywords do plot
- Detec√ß√£o de sub-g√™neros (slasher, found footage, etc.)

**2. Modelos Avan√ßados:**
- XGBoost para melhor performance
- LSTM para previs√£o temporal (tend√™ncias)
- Ensemble de modelos (voting)

**3. Infraestrutura:**
- Cache com Redis (reduzir queries)
- Message Queue (SQS/RabbitMQ)
- Deploy em Kubernetes

**4. Observabilidade:**
- Prometheus + Grafana (m√©tricas)
- ELK Stack (logs centralizados)
- Alertas autom√°ticos (model drift)

---

## üìà M√©tricas de Sucesso

### T√©cnicas
- ‚úÖ Coleta de ~5.000 filmes de terror
- ‚úÖ 3 modelos treinados com sucesso
- ‚úÖ R¬≤ > 0.75 (boa capacidade preditiva)
- ‚úÖ Accuracy > 0.80 (classifica√ß√£o confi√°vel)
- ‚úÖ Dashboard com atualiza√ß√£o autom√°tica

### Neg√≥cio
- üìä Identifica√ß√£o de padr√µes de sucesso
- üéØ Redu√ß√£o de risco em investimentos
- üí° Insights acion√°veis para stakeholders
- ‚è±Ô∏è Decis√µes baseadas em dados em tempo real

---

## üéì Aprendizados e Decis√µes T√©cnicas

### Por que Flask?
- ‚úÖ Simplicidade e flexibilidade
- ‚úÖ Ecossistema Python (scikit-learn, pandas)
- ‚úÖ F√°cil integra√ß√£o com Celery
- ‚ùå N√£o precisa de SPA complexo (React/Vue)

### Por que Celery?
- ‚úÖ Processamento ass√≠ncrono nativo em Python
- ‚úÖ Celery Beat integrado (scheduler)
- ‚úÖ Retry autom√°tico de tasks
- ‚ùå Apache Airflow seria overkill

### Por que MySQL?
- ‚úÖ Queries relacionais complexas (JOINs)
- ‚úÖ Transa√ß√µes ACID
- ‚úÖ Familiar para maioria dos devs
- ‚ùå PostgreSQL seria alternativa v√°lida

### Por que Redis?
- ‚úÖ Alta performance (in-memory)
- ‚úÖ Simples de configurar
- ‚úÖ Serve broker + backend
- ‚ùå RabbitMQ seria mais robusto, mas complexo

### Por que Random Forest?
- ‚úÖ Robusto a overfitting
- ‚úÖ Feature importance interpret√°vel
- ‚úÖ Sem necessidade de feature scaling (mas usamos)
- ‚ùå Deep Learning seria overkill para dados tabulares

---

## üîç Insights do Projeto

### 1. Padr√µes Identificados
- üìÖ Filmes lan√ßados em **outubro** t√™m 35% mais impacto
- üé≠ Combinar **Horror + Thriller** aumenta popularidade
- ‚è±Ô∏è Dura√ß√£o ideal: **90-105 minutos** (n√£o muito longo)
- üåç Filmes em **ingl√™s** t√™m alcance maior

### 2. Descobertas Inesperadas
- Filmes de terror indie (low budget) formam cluster distinto
- Vote count √© mais importante que vote average para popularidade
- Filmes de dezembro (√©poca de festas) tamb√©m performam bem
- Terror sobrenatural domina o mercado p√≥s-2010

### 3. Desafios Superados
- **Rate limiting TMDB:** Implementado sleep adaptativo
- **Data quality:** Filtro de m√≠nimo de votos
- **Model drift:** Re-treinamento autom√°tico a cada 10h
- **Cold start:** Init-DB garante estrutura antes de tasks

---

## üìö Recursos e Refer√™ncias

### Documenta√ß√£o Oficial
- [Flask](https://flask.palletsprojects.com/)
- [Celery](https://docs.celeryproject.org/)
- [SQLAlchemy](https://www.sqlalchemy.org/)
- [scikit-learn](https://scikit-learn.org/)
- [TMDB API](https://developers.themoviedb.org/)

### Conceitos Aplicados
- **Microservices:** Separa√ß√£o de responsabilidades (web, worker, beat)
- **ETL Pipeline:** Extract (TMDB) ‚Üí Transform (features) ‚Üí Load (MySQL)
- **ML Pipeline:** Coleta ‚Üí Feature Engineering ‚Üí Treino ‚Üí Predi√ß√£o
- **Async Processing:** Tasks pesadas fora do request/response
- **Polling Pattern:** Atualiza√ß√£o peri√≥dica sem WebSocket

---

## üé¨ Conclus√£o

Este projeto demonstra uma arquitetura moderna e escal√°vel para problemas de **Machine Learning em produ√ß√£o**:

```mermaid
mindmap
  root((TMDB<br/>Horror<br/>Predictor))
    Coleta Automatizada
      Celery Beat
      TMDB API
      Upsert Strategy
    Machine Learning
      Random Forest
      Feature Engineering
      3 Modelos
    Visualiza√ß√£o
      Dashboard Web
      Chart.js
      Polling Real-time
    Infraestrutura
      Docker Compose
      MySQL
      Redis
      Flask
```

**Principais Conquistas:**
1. ‚úÖ Sistema 100% automatizado
2. ‚úÖ Dados sempre atualizados
3. ‚úÖ Modelos re-treinados periodicamente
4. ‚úÖ Insights visuais e acion√°veis
5. ‚úÖ Arquitetura escal√°vel e manuten√≠vel

**Aplica√ß√µes Reais:**
- üé¨ Produtoras de cinema
- üì∫ Plataformas de streaming
- üí∞ Investidores de entretenimento
- üìä Analistas de mercado
- üéì Pesquisadores acad√™micos

---

**Desenvolvido com ‚ù§Ô∏è para aprender e aplicar:**
- Data Engineering
- Machine Learning
- DevOps
- Software Architecture
- Python Ecosystem



